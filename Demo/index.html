<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScriptaV3 Compiler Demo</title>

    <!-- KaTeX CSS (needed for page styling) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        /* CodeMirror container styling */
        codemirror-editor {
            display: block;
            height: 100%;
            width: 100%;
        }

        /* Highlight for rendered text when syncing from source (Ctrl+S) */
        .rendered-sync-highlight {
            background-color: rgba(0, 255, 255, 0.5) !important;
            outline: 2px solid cyan;
        }
    </style>

    <!-- Import map to ensure CodeMirror packages share the same @codemirror/state instance -->
    <script type="importmap">
    {
        "imports": {
            "@codemirror/state": "https://esm.sh/@codemirror/state@6.4.1",
            "@codemirror/view": "https://esm.sh/@codemirror/view@6.26.0?external=@codemirror/state",
            "@codemirror/commands": "https://esm.sh/@codemirror/commands@6.3.3?external=@codemirror/state,@codemirror/view,@codemirror/language",
            "@codemirror/autocomplete": "https://esm.sh/@codemirror/autocomplete@6.15.0?external=@codemirror/state,@codemirror/view,@codemirror/language,@lezer/common",
            "@codemirror/language": "https://esm.sh/@codemirror/language@6.10.1?external=@codemirror/state,@codemirror/view,@lezer/common,@lezer/highlight,@lezer/lr",
            "@codemirror/search": "https://esm.sh/@codemirror/search@6.5.6?external=@codemirror/state,@codemirror/view",
            "@codemirror/lint": "https://esm.sh/@codemirror/lint@6.5.0?external=@codemirror/state,@codemirror/view",
            "@lezer/common": "https://esm.sh/@lezer/common@1.2.1",
            "@lezer/highlight": "https://esm.sh/@lezer/highlight@1.2.0?external=@lezer/common",
            "@lezer/lr": "https://esm.sh/@lezer/lr@1.4.0?external=@lezer/common",
            "codemirror": "https://esm.sh/codemirror@6.0.1?external=@codemirror/state,@codemirror/view,@codemirror/commands,@codemirror/autocomplete,@codemirror/language,@codemirror/search,@codemirror/lint"
        }
    }
    </script>

    <!-- Load CodeMirror custom element as ES module -->
    <script type="module" src="codemirror-element.js"></script>
</head>
<body>
    <div id="app"></div>

    <script src="main.js"></script>
    <script>
        // localStorage keys
        var OLD_STORAGE_KEY = 'scripta-demo-source';
        var STORAGE_KEY = 'scripta-demo-documents';

        // Load documents from localStorage
        var documentsJson = localStorage.getItem(STORAGE_KEY);
        var documents = [];

        if (documentsJson) {
            // Parse existing documents
            try {
                documents = JSON.parse(documentsJson);
            } catch (e) {
                console.error('Failed to parse documents:', e);
                documents = [];
            }
        } else {
            // Check for migration from old format
            var oldSource = localStorage.getItem(OLD_STORAGE_KEY);
            if (oldSource) {
                // Migrate old single document to new format
                documents = [{
                    id: 'doc-1',
                    title: extractTitle(oldSource),
                    content: oldSource
                }];
                // Save migrated documents and remove old key
                localStorage.setItem(STORAGE_KEY, JSON.stringify(documents));
                localStorage.removeItem(OLD_STORAGE_KEY);
            }
        }

        // Helper function to extract title from content
        // Handles title blocks with or without properties: "| title" or "| title number-to-level:2"
        function extractTitle(content) {
            var lines = content.split('\n');
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].trim().startsWith('| title')) {
                    // Title text is on the next line
                    if (i + 1 < lines.length) {
                        var titleText = lines[i + 1].trim();
                        return titleText || 'Untitled';
                    }
                    break;
                }
            }
            return 'Untitled';
        }

        // Initialize Elm app with flags
        var app = Elm.Main.init({
            node: document.getElementById('app'),
            flags: {
                documents: documents
            }
        });

        // Subscribe to saveDocuments port
        app.ports.saveDocuments.subscribe(function(docs) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(docs));
        });

        // Subscribe to selectInEditor port - sync rendered text clicks to editor
        app.ports.selectInEditor.subscribe(function(selection) {
            // selection = { lineNumber, begin, end }
            var editorElement = document.querySelector('codemirror-editor');
            if (editorElement && editorElement.editor) {
                var editor = editorElement.editor;
                var doc = editor.state.doc;

                // Get the start position of the target line (1-indexed to 0-indexed)
                var lineStart = doc.line(selection.lineNumber).from;

                // Calculate absolute positions (end is inclusive, so add 1 for CodeMirror's exclusive range)
                var from = lineStart + selection.begin;
                var to = lineStart + selection.end + 1;

                // Use the setSyncHighlight effect (imported in codemirror-element.js)
                // We need to access it via the editor's custom property
                if (editorElement.setSyncHighlight) {
                    // Import EditorView.scrollIntoView to center the highlighted text
                    editor.dispatch({
                        effects: [
                            editorElement.setSyncHighlight({ from, to }),
                            // Scroll to center the highlighted line in the view
                            editorElement.scrollToCenter(from)
                        ].filter(Boolean)
                    });
                }

                // Focus the editor
                editor.focus();
            }
        });

        // Flag to track when we've handled a text selection
        var handledTextSelection = false;

        // Prevent click events from firing when we just handled a text selection
        document.addEventListener('click', function(e) {
            if (handledTextSelection) {
                handledTextSelection = false;
                e.stopPropagation();
                e.preventDefault();
                return false;
            }
        }, true); // Use capture phase to intercept before Elm

        // Handle text selection in rendered output
        document.addEventListener('mouseup', function(e) {
            handledTextSelection = false; // Reset flag
            var renderedOutput = document.getElementById('rendered-output');
            if (!renderedOutput || !renderedOutput.contains(e.target)) {
                return; // Click was outside rendered output
            }

            var selection = window.getSelection();
            if (!selection || selection.isCollapsed || selection.rangeCount === 0) {
                return; // No selection or collapsed selection (this is a click, let Elm handle it)
            }

            // We have a real selection, set flag to block the subsequent click event
            handledTextSelection = true;

            var range = selection.getRangeAt(0);

            // Find elements with position data at start and end of selection
            function findPositionElement(node) {
                // Walk up to find an element with data-begin attribute
                var el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
                while (el && el !== renderedOutput) {
                    if (el.hasAttribute && el.hasAttribute('data-begin')) {
                        return el;
                    }
                    el = el.parentElement;
                }
                return null;
            }

            function parseLineNumber(id) {
                // ID format: "e-{lineNumber}.{tokenIndex}"
                if (!id || !id.startsWith('e-')) return null;
                var parts = id.substring(2).split('.');
                return parseInt(parts[0], 10);
            }

            var startEl = findPositionElement(range.startContainer);
            var endEl = findPositionElement(range.endContainer);

            if (!startEl || !endEl) {
                return; // Could not find position elements
            }

            var startLine = parseLineNumber(startEl.id);
            var endLine = parseLineNumber(endEl.id);
            var startBegin = parseInt(startEl.getAttribute('data-begin'), 10);
            var endEnd = parseInt(endEl.getAttribute('data-end'), 10);

            if (startLine === null || endLine === null || isNaN(startBegin) || isNaN(endEnd)) {
                return; // Invalid data
            }

            // Calculate character positions within the elements
            // startOffset/endOffset are offsets within the text node
            // Add 1 to account for off-by-one between rendered text and source positions
            var startChar = startBegin + range.startOffset + 1;
            var endChar;

            if (startEl === endEl) {
                // Selection within same element
                endChar = startBegin + range.endOffset + 1;
            } else {
                // Selection spans multiple elements
                // For end element, use its data-begin + offset within that element
                var endElBegin = parseInt(endEl.getAttribute('data-begin'), 10);
                endChar = endElBegin + range.endOffset + 1;
            }

            console.log('Selection debug:', {
                startEl: startEl.id,
                endEl: endEl.id,
                startLine, endLine,
                startBegin, endEnd,
                'range.startOffset': range.startOffset,
                'range.endOffset': range.endOffset,
                startChar, endChar
            });

            // Send directly to CodeMirror editor
            var editorElement = document.querySelector('codemirror-editor');
            if (editorElement && editorElement.editor) {
                var editor = editorElement.editor;
                var doc = editor.state.doc;

                // For paragraphs that span multiple lines, we need to find the
                // absolute position by counting characters from the start line
                function findAbsolutePosition(lineNum, charOffset) {
                    var pos = doc.line(lineNum).from;
                    var remaining = charOffset;
                    var currentLine = lineNum;

                    while (remaining > 0 && currentLine <= doc.lines) {
                        var lineLength = doc.line(currentLine).length;
                        if (remaining <= lineLength) {
                            return pos + remaining;
                        }
                        // Move to next line (+1 for newline character)
                        remaining -= (lineLength + 1);
                        currentLine++;
                        if (currentLine <= doc.lines) {
                            pos = doc.line(currentLine).from;
                        }
                    }
                    return pos + Math.max(0, remaining);
                }

                var from = findAbsolutePosition(startLine, startChar);
                var to = findAbsolutePosition(endLine, endChar);

                // Use sync highlight and scroll to center
                if (editorElement.setSyncHighlight) {
                    editor.dispatch({
                        effects: [
                            editorElement.setSyncHighlight({ from, to }),
                            editorElement.scrollToCenter(from)
                        ].filter(Boolean)
                    });
                }

                editor.focus();
            }
        });

        // Handle Ctrl+S sync from source to rendered (left-to-right sync)
        document.addEventListener('sync-to-rendered', function(e) {
            var detail = e.detail;
            var lineNumber = detail.lineNumber;
            var charOffset = detail.charOffset;

            console.log('Sync to rendered:', detail);

            // Clear any previous highlight
            document.querySelectorAll('.rendered-sync-highlight').forEach(el => {
                el.classList.remove('rendered-sync-highlight');
            });

            var renderedOutput = document.getElementById('rendered-output');
            if (!renderedOutput) return;

            // Find all elements with data-begin attribute (rendered text elements)
            var allElements = renderedOutput.querySelectorAll('[data-begin]');

            // Find the element whose line number is <= selected line and closest to it
            // This handles multi-line paragraphs where the element's line number is the start of the block
            var bestMatch = null;
            var bestLineDistance = Infinity;

            allElements.forEach(function(el) {
                var elId = el.id;
                if (!elId || !elId.startsWith('e-')) return;

                var elLineStr = elId.substring(2).split('.')[0];
                var elLine = parseInt(elLineStr, 10);

                if (isNaN(elLine)) return;

                // The element's line should be <= the selected line (block starts before or at selection)
                if (elLine <= lineNumber) {
                    var distance = lineNumber - elLine;
                    if (distance < bestLineDistance) {
                        bestLineDistance = distance;
                        bestMatch = el;
                    }
                }
            });

            if (bestMatch) {
                // Highlight the matched element
                bestMatch.classList.add('rendered-sync-highlight');

                // Scroll it into view
                bestMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });

                console.log('Highlighted element:', bestMatch.id, 'lineDistance:', bestLineDistance);
            } else {
                console.log('No matching element found');
            }
        });

        // Load KaTeX and initialize math-text custom element (V2 approach)
        function initKatex() {
            class MathText extends HTMLElement {
                constructor() {
                    super();
                }

                connectedCallback() {
                    this.attachShadow({mode: "open"});
                    this.shadowRoot.innerHTML =
                        katex.renderToString(
                            this.content,
                            {
                                throwOnError: false,
                                displayMode: this.display,
                                trust: true
                            }
                        );
                    let link = document.createElement('link');
                    link.setAttribute('rel', 'stylesheet');
                    link.setAttribute('href', 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css');
                    this.shadowRoot.appendChild(link);
                }
            }

            customElements.define('math-text', MathText);
        }

        // Load KaTeX script dynamically
        var katexJs = document.createElement('script');
        katexJs.type = 'text/javascript';
        katexJs.onload = function() {
            initKatex();
        };
        katexJs.src = "https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js";
        document.head.appendChild(katexJs);
    </script>
</body>
</html>
